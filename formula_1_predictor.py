# -*- coding: utf-8 -*-
"""formula_1_predictor.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Vyy4fOnKZ8Tch01yv2zxnFfQxlZhL57O

# **FORMULA ONE WINNER PREDICTION **


This project is aimed towards predicting the future F1 GP winners based on the driver and constructors perfomance

F1 Constructors performance are largely dependent on the FIA techinical regulation (power unit,fuel system,brake system limitations) for the season. After the 2013 season new engine regulation were made (Hybrid era) Mercedes-Benz are most dominat team since followed bY Redbull Racing and Scuderia Ferrari. Rules have been changed after the 2021 so whatever analysis made here will not apply for 2022 season and so far. only data after 2010 will be considered in the following analysis.
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.preprocessing import StandardScaler,LabelEncoder
from sklearn.linear_model import LogisticRegression
from sklearn.ensemble import RandomForestClassifier
from sklearn.svm import SVC
from sklearn.tree import DecisionTreeClassifier
from sklearn.neighbors import KNeighborsClassifier
from sklearn.naive_bayes import GaussianNB
from sklearn.model_selection import train_test_split
from sklearn.model_selection import cross_validate
from sklearn import metrics
import seaborn as sns

from google.colab import drive
drive.mount('/content/drive/')

"""# loading the datasets from the drive"""

results = pd.read_csv(r'/content/drive/MyDrive/nit project/results.csv')
races = pd.read_csv(r'/content/drive/MyDrive/nit project/races.csv')
quali = pd.read_csv(r'/content/drive/MyDrive/nit project/qualifying.csv')
drivers = pd.read_csv(r'/content/drive/MyDrive/nit project/drivers.csv')
constructors = pd.read_csv(r'/content/drive/MyDrive/nit project/constructors.csv')
circuit = pd.read_csv(r'/content/drive/MyDrive/nit project/circuits.csv')

"""# Merging the datasets based on the particular columns"""

df1 = pd.merge(races,results,how='inner',on=['raceId'])
df2 = pd.merge(df1,quali,how='inner',on=['raceId','driverId','constructorId'])
df3 = pd.merge(df2,drivers,how='inner',on=['driverId'])
df4 = pd.merge(df3,constructors,how='inner',on=['constructorId'])
df5 = pd.merge(df4,circuit,how='inner',on=['circuitId'])

df5.head(10)

df5.info()

data = df5.drop(['round','circuitId','time_x','url_x','resultId',
                 'constructorId','number_x','positionText','position_x',
                 'positionOrder','laps','time_y','rank',
                 'fastestLapTime','fastestLapSpeed','qualifyId','driverRef','number','code','url_y','circuitRef',
                 'location','lat','lng','alt','number_y','points','constructorRef','name_x','raceId','fastestLap','q2','q3','milliseconds','q1'],1)
data.rename(columns={'name_y':'constructor'},inplace=True)
data.rename(columns={'nationality_x':'driver_nationality'},inplace=True)
data.rename(columns={'nationality_y':'constructor_nationality'},inplace=True)
data.info()

"""### **since the regulations changed after the 2010 season, we consider only the data only from the year 2010**"""

data=data[data['year']>=2010]
data.head()

""" a lot of changes has happened in formula one as years go by, the teams have changed their constructor name due to ownership changes and lot of other factors. So we need to change the data accordingly. We also reduce some columns

"""

#renaming colums
data['driver'] = data['forename']+' '+data['surname']
data['date'] = pd.to_datetime(data['date'])
data['dob'] = pd.to_datetime(data['dob'])
#creating age parameters
data['age_at_gp_in_days'] = abs(data['dob']-data['date'])
data['age_at_gp_in_days'] = data['age_at_gp_in_days'].apply(lambda x: str(x).split(' ')[0])
#renaming constructors names
data['constructor'] = data['constructor'].apply(lambda x: 'Racing Point' if x=='Force India' else x)
data['constructor'] = data['constructor'].apply(lambda x: 'Alfa Romeo' if x=='Sauber' else x)
data['constructor'] = data['constructor'].apply(lambda x: 'Renault' if x=='Lotus F1' else x)
data['constructor'] = data['constructor'].apply(lambda x: 'AlphaTauri' if x=='Toro Rosso' else x)
data.head()

data['driver_nationality'] = data['driver_nationality'].apply(lambda x: str(x)[:3])
data['constructor_nationality'] = data['constructor_nationality'].apply(lambda x: str(x)[:3])
data['country'] = data['country'].apply(lambda x: 'Bri' if x=='UK' else x)
data['country'] = data['country'].apply(lambda x: 'Ame' if x=='USA' else x)
data['country'] = data['country'].apply(lambda x: 'Fre' if x=='Fra' else x)
data['country'] = data['country'].apply(lambda x: str(x)[:3])
data['driver_home'] = data['driver_nationality'] == data['country']
data['constructor_home'] = data['constructor_nationality'] == data['country']
data['driver_home'] = data['driver_home'].apply(lambda x: int(x))
data['constructor_home'] = data['constructor_home'].apply(lambda x: int(x))
data.head()

"""To calculate the dnf ratio we create 2 columns based on the incident whether the driver was not able to finish the race because of constructors problem or his own mistakes and we assign 0 and 1 respectively"""

data['driver_dnf'] = data['statusId'].apply(lambda x: 1 if x in [3,4,20,29,31,41,68,73,81,97,82,104,107,130,137] else 0)
data['constructor_dnf'] = data['statusId'].apply(lambda x: 1 if x not in [3,4,20,29,31,41,68,73,81,97,82,104,107,130,137,1] else 0)

"""A driver is declared DNF (did not finish) when he is not able to finish the race. It can be because of many reasons due to mechanical failure of the car, physical damage to the car,brake failure,pit crew mistakes, driver's mistake etc. We calculate the dnf rate of each driver and constructor and we visualize it using a simple bar graph."""

#dnf of drivers
dnf_by_driver = data.groupby('driver').sum()['driver_dnf']
driver_race_entered = data.groupby('driver').count()['driver_dnf']
driver_dnf_ratio = (dnf_by_driver*100/driver_race_entered).sort_values(ascending=False)
plt.figure(figsize=(30,10))
bars = plt.bar(driver_dnf_ratio.index,height=driver_dnf_ratio,align='center',width=0.5)
plt.xticks(rotation=90)
plt.xlabel('Drivers')
plt.ylabel('Driver DNF ratio')
plt.title('DNFs ratio due to driver error')
plt.show()

#we calculate the driver confience
dnf_by_driver = data.groupby('driver').sum()['driver_dnf']
driver_race_entered = data.groupby('driver').count()['driver_dnf']
driver_dnf_ratio = (dnf_by_driver/driver_race_entered)
driver_confidence = 1-driver_dnf_ratio
driver_confidence_dict = dict(zip(driver_confidence.index,driver_confidence))

#dnf by constructors
dnf_by_constructor = data.groupby('constructor').sum()['constructor_dnf']
constructor_race_entered = data.groupby('constructor').count()['constructor_dnf']
constructor_dnf_ratio = (dnf_by_constructor*100/constructor_race_entered).sort_values(ascending=False)
plt.figure(figsize=(30,10))
bars = plt.bar(constructor_dnf_ratio.index,height=constructor_dnf_ratio,align='center',width=0.8)
plt.xticks(rotation=90)
plt.xlabel('Constructors')
plt.ylabel('Constructor DNF ratio')
plt.title('DNFs ratio due to constructor error')
plt.show()

#we calculate the constructor reliability
dnf_by_constructor = data.groupby('constructor').sum()['constructor_dnf']
constructor_race_entered = data.groupby('constructor').count()['constructor_dnf']
constructor_dnf_ratio = (dnf_by_constructor/constructor_race_entered)
constructor_relaiblity = 1-constructor_dnf_ratio
constructor_relaiblity_dict = dict(zip(constructor_relaiblity.index,constructor_relaiblity))

#adding driver confidence and constructor reliability to the dataframe
data['driver_confidence'] = data['driver'].apply(lambda x:driver_confidence_dict[x])
data['constructor_relaiblity'] = data['constructor'].apply(lambda x:constructor_relaiblity_dict[x])
data.rename(columns={'grid':'quali_position'},inplace=True)
data.rename(columns={'position_y':'position'},inplace=True)
data.rename(columns={'name':'GP_name'},inplace=True)

"""A single formula one season will comprise of only 10 teams and 2 drivers in each team. We can remove the retired drivers and constructors and focus only on present drivers and constructors"""

active_constructors = ['Renault', 'Williams', 'McLaren', 'Ferrari', 'Mercedes',
                       'AlphaTauri', 'Racing Point', 'Alfa Romeo', 'Red Bull',
                       'Haas F1 Team']
active_drivers = ['Daniel Ricciardo', 'Kevin Magnussen', 'Carlos Sainz',
                  'Valtteri Bottas', 'Lance Stroll', 'George Russell',
                  'Lando Norris', 'Sebastian Vettel', 'Kimi Räikkönen',
                  'Charles Leclerc', 'Lewis Hamilton', 'Daniil Kvyat',
                  'Max Verstappen', 'Pierre Gasly', 'Alexander Albon',
                  'Sergio Pérez', 'Esteban Ocon', 'Antonio Giovinazzi',
                  'Romain Grosjean','Nicholas Latifi']
data['active_driver'] = data['driver'].apply(lambda x: int(x in active_drivers))
data['active_constructor'] = data['constructor'].apply(lambda x: int(x in active_constructors))
active_data1=data[['GP_name','quali_position','constructor','driverId','position','driver_confidence','constructor_relaiblity','active_driver','active_constructor','dob']]
active_data1 = active_data1[(active_data1['active_driver']==1)&(active_data1['active_constructor']==1)]

active_data = active_data1[['GP_name','quali_position','constructor','driverId','position','driver_confidence','constructor_relaiblity']]

"""top 3 places are considered a podium and they are given the value 1 and and positions 4 to 10 are given value of 2 since drivers
finishing in those positions would score points and the rest of the positions are pointless and are assigned a value of 3"""
def position_index(x):
    if x<4:
        return 1
    if x>10:
        return 3
    else :
        return 2

#using label encoder and standard scaler
sc  = StandardScaler()
le = LabelEncoder()
active_data['GP_name'] = le.fit_transform(active_data['GP_name'])
active_data['constructor'] = le.fit_transform(active_data['constructor'])
active_data['GP_name'] = le.fit_transform(active_data['GP_name'])
X = active_data.drop(['position'],1)
y = active_data['position'].apply(lambda x: position_index(x))
active_data.head(100)
from sklearn.model_selection import train_test_split
X_train,X_test,y_train,y_test=train_test_split(X,y,test_size=0.8,random_state=10)

models = [LogisticRegression(),DecisionTreeClassifier(),RandomForestClassifier(),SVC(),GaussianNB(),KNeighborsClassifier()]
names = ['LogisticRegression','DecisionTreeClassifier','RandomForestClassifier',SVC(),'GaussianNB','KNeighborsClassifier']
model_dict = dict(zip(models,names))
mean_results = []
results = []
name = []
for model in models:
  result=cross_validate(model, X, y, cv=3)
  result1=[]
  for i in result['test_score']:
    result1.append(i)
  mean_results.append(sum(result1) / len(result1))
  results.append(result1)
  name.append(model_dict[model])
  print(f'{model_dict[model]} : {sum(result1) / len(result1)}')

model=LogisticRegression()
y1=model.fit(X,y)
y2=model.predict(X)
cm=metrics.confusion_matrix(y,y2)
print(model)
sns.heatmap(cm,annot=True)

model=DecisionTreeClassifier()
y1=model.fit(X,y)
y2=model.predict(X)
cm=metrics.confusion_matrix(y,y2)
print(model)
sns.heatmap(cm,annot=True)

model=RandomForestClassifier()
y1=model.fit(X,y)
y2=model.predict(X)
cm=metrics.confusion_matrix(y,y2)
print(model)
sns.heatmap(cm,annot=True)

model=SVC()
y1=model.fit(X,y)
y2=model.predict(X)
cm=metrics.confusion_matrix(y,y2)
print(model)
sns.heatmap(cm,annot=True)

model=GaussianNB()
y1=model.fit(X,y)
y2=model.predict(X)
cm=metrics.confusion_matrix(y,y2)
print(model)
sns.heatmap(cm,annot=True)

model=KNeighborsClassifier()
y1=model.fit(X,y)
y2=model.predict(X)
cm=metrics.confusion_matrix(y,y2)
print(model)
sns.heatmap(cm,annot=True)

"""**COMPARING THE MODEL PERFOMANCE USING BOX PLOT**"""

plt.figure(figsize=(15,10))
plt.boxplot(x=results,labels=name)
plt.xlabel('Models')
plt.ylabel('accuracy')
plt.title('Model performance comparision')
plt.show()

active_data.info()

import pandas as pd
import networkx as nx
import matplotlib.pyplot as plt

# Create an empty graph
graph = nx.Graph()

# Iterate over the dataset rows
for _, row in active_data.iterrows():
    GP_name	=row['GP_name']
    driver = row['driverId']
    constructor = row['constructor']
    position = row['position']
    quali_position = row['quali_position']
    GP_name = row['GP_name']

    # Add nodes to the graph
    graph.add_node(GP_name, label=GP_name)
    graph.add_node(driver, label=driver)
    graph.add_node(constructor, label=constructor)
    graph.add_node(position, label=position)
    graph.add_node(quali_position, label=quali_position)
    graph.add_node(GP_name, label=GP_name)

    # Add edges to the graph
    graph.add_edge(driver, constructor)


# Set node positions using a spring layout
pos = nx.spring_layout(graph, k=0.3, seed=42)

# Set node and edge attributes for visualization
node_color = 'lightblue'
node_size = 2000
edge_color = 'gray'
font_size = 10
font_weight = 'bold'
alpha = 0.8
width = 0.5
node_shape = 'o'
linewidths = 1
font_color = 'black'

# Draw the graph
plt.figure(figsize=(12, 8))
nx.draw_networkx(
    graph,
    pos,
    with_labels=False,
    node_size=node_size,
    node_color=node_color,
    edge_color=edge_color,
    font_size=font_size,
    font_weight=font_weight,
    alpha=alpha,
    width=width,
    node_shape=node_shape,
    linewidths=linewidths,
    font_color=font_color
)

# Draw node labels separately for better visibility
node_labels = nx.get_node_attributes(graph, 'label')
nx.draw_networkx_labels(graph, pos, labels=node_labels, font_size=8)

# Set plot title
plt.title('Knowledge Graph for team')

# Display the graph
plt.axis('off')
plt.show()

import pandas as pd
import networkx as nx
import matplotlib.pyplot as plt

# Create an empty graph
graph = nx.Graph()

# Iterate over the dataset rows
for _, row in active_data.iterrows():
    GP_name	=row['GP_name']
    driver = row['driverId']
    constructor = row['constructor']
    position = row['position']
    quali_position = row['quali_position']
    GP_name = row['GP_name']

    # Add nodes to the graph
    graph.add_node(GP_name, label=GP_name)
    graph.add_node(driver, label=driver)
    graph.add_node(constructor, label=constructor)
    graph.add_node(position, label=position)
    graph.add_node(quali_position, label=quali_position)
    graph.add_node(GP_name, label=GP_name)

    # Add edges to the graph
    graph.add_edge(driver, position)


# Set node positions using a spring layout
pos = nx.spring_layout(graph, k=0.3, seed=42)

# Set node and edge attributes for visualization
node_color = 'lightblue'
node_size = 2000
edge_color = 'gray'
font_size = 10
font_weight = 'bold'
alpha = 0.8
width = 0.5
node_shape = 'o'
linewidths = 1
font_color = 'black'

# Draw the graph
plt.figure(figsize=(12, 8))
nx.draw_networkx(
    graph,
    pos,
    with_labels=False,
    node_size=node_size,
    node_color=node_color,
    edge_color=edge_color,
    font_size=font_size,
    font_weight=font_weight,
    alpha=alpha,
    width=width,
    node_shape=node_shape,
    linewidths=linewidths,
    font_color=font_color
)

# Draw node labels separately for better visibility
node_labels = nx.get_node_attributes(graph, 'label')
nx.draw_networkx_labels(graph, pos, labels=node_labels, font_size=8)

# Set plot title
plt.title('Knowledge Graph for driver position')

# Display the graph
plt.axis('off')
plt.show()

import pandas as pd
import networkx as nx
import matplotlib.pyplot as plt

# Create an empty graph
graph = nx.Graph()

# Iterate over the dataset rows
for _, row in active_data.iterrows():
    GP_name =row['GP_name']
    driver = row['driverId']
    constructor = row['constructor']
    position = row['position']
    quali_position = row['quali_position']
    GP_name = row['GP_name']

    # Add nodes to the graph
    graph.add_node(GP_name, label=GP_name)
    graph.add_node(driver, label=driver)
    graph.add_node(constructor, label=constructor)
    graph.add_node(position, label=position)
    graph.add_node(quali_position, label=quali_position)
    graph.add_node(GP_name, label=GP_name)

    # Add edges to the graph
    graph.add_edge(quali_position < 4, position < 4)


# Set node positions using a spring layout
pos = nx.spring_layout(graph, k=0.3, seed=42)

# Set node and edge attributes for visualization
node_color = 'lightblue'
node_size = 2000
edge_color = 'gray'
font_size = 10
font_weight = 'bold'
alpha = 0.8
width = 0.5
node_shape = 'o'
linewidths = 1
font_color = 'black'

# Draw the graph
plt.figure(figsize=(12, 8))
nx.draw_networkx(
    graph,
    pos,
    with_labels=False,
    node_size=node_size,
    node_color=node_color,
    edge_color=edge_color,
    font_size=font_size,
    font_weight=font_weight,
    alpha=alpha,
    width=width,
    node_shape=node_shape,
    linewidths=linewidths,
    font_color=font_color
)

# Draw node labels separately for better visibility
node_labels = nx.get_node_attributes(graph, 'label')
nx.draw_networkx_labels(graph, pos, labels=node_labels, font_size=8)

# Set plot title
plt.title('Knowledge Graph for qualification reliability')

# Display the graph
plt.axis('off')
plt.show()

import pandas as pd
import networkx as nx
import matplotlib.pyplot as plt

# Create an empty graph
graph = nx.Graph()

# Iterate over the dataset rows
for _, row in active_data.iterrows():
    GP_name =row['GP_name']
    driver = row['driverId']
    constructor = row['constructor']
    position = row['position']
    quali_position = row['quali_position']
    GP_name = row['GP_name']

    # Add nodes to the graph
    graph.add_node(GP_name, label=GP_name)
    graph.add_node(driver, label=driver)
    graph.add_node(constructor, label=constructor)
    graph.add_node(position, label=position)
    graph.add_node(quali_position, label=quali_position)
    graph.add_node(GP_name, label=GP_name)

    # Add edges to the graph
    graph.add_edge(GP_name, position < 4)


# Set node positions using a spring layout
pos = nx.spring_layout(graph, k=0.3, seed=42)

# Set node and edge attributes for visualization
node_color = 'lightblue'
node_size = 2000
edge_color = 'gray'
font_size = 10
font_weight = 'bold'
alpha = 0.8
width = 0.5
node_shape = 'o'
linewidths = 1
font_color = 'black'

# Draw the graph
plt.figure(figsize=(12, 8))
nx.draw_networkx(
    graph,
    pos,
    with_labels=False,
    node_size=node_size,
    node_color=node_color,
    edge_color=edge_color,
    font_size=font_size,
    font_weight=font_weight,
    alpha=alpha,
    width=width,
    node_shape=node_shape,
    linewidths=linewidths,
    font_color=font_color
)

# Draw node labels separately for better visibility
node_labels = nx.get_node_attributes(graph, 'label')
nx.draw_networkx_labels(graph, pos, labels=node_labels, font_size=8)

# Set plot title
plt.title('Knowledge Graph for driver reliability on a track')

# Display the graph
plt.axis('off')
plt.show()

import pandas as pd
import networkx as nx
import matplotlib.pyplot as plt

# Create an empty graph
graph = nx.Graph()

# Iterate over the dataset rows
for _, row in active_data.iterrows():
    GP_name	=row['GP_name']
    driver = row['driverId']
    constructor = row['constructor']
    position = row['position']
    quali_position = row['quali_position']
    GP_name = row['GP_name']

    # Add nodes to the graph
    graph.add_node(GP_name, label=GP_name)
    graph.add_node(driver, label=driver)
    graph.add_node(constructor, label=constructor)
    graph.add_node(position, label=position)
    graph.add_node(quali_position, label=quali_position)
    graph.add_node(GP_name, label=GP_name)

    # Add edges to the graph
    graph.add_edge(driver, constructor)
    graph.add_edge(driver, position)
    graph.add_edge(driver, quali_position)
    graph.add_edge(position, quali_position)
    graph.add_edge(position, GP_name)


# Set node positions using a spring layout
pos = nx.spring_layout(graph, k=0.3, seed=42)

# Set node and edge attributes for visualization
node_color = 'lightblue'
node_size = 2000
edge_color = 'gray'
font_size = 10
font_weight = 'bold'
alpha = 0.8
width = 0.5
node_shape = 'o'
linewidths = 1
font_color = 'black'

# Draw the graph
plt.figure(figsize=(12, 8))
nx.draw_networkx(
    graph,
    pos,
    with_labels=False,
    node_size=node_size,
    node_color=node_color,
    edge_color=edge_color,
    font_size=font_size,
    font_weight=font_weight,
    alpha=alpha,
    width=width,
    node_shape=node_shape,
    linewidths=linewidths,
    font_color=font_color
)

# Draw node labels separately for better visibility
node_labels = nx.get_node_attributes(graph, 'label')
nx.draw_networkx_labels(graph, pos, labels=node_labels, font_size=8)

# Set plot title
plt.title('Knowledge Graph')

# Display the graph
plt.axis('off')
plt.show()

active_data.info()

